###FILE-START:.gitignore###
Config.psd1
*git-ignore*
.github/copilot-instructions.md


###FILE-END:.gitignore###

###FILE-START:Colors.ps1###
# Color variables for easy peasy splatting :-)
$Green = @{
    Background = 'Black'
    Foreground = 'Green'
}
$Cyan = @{
    Background = 'Black'
    Foreground = 'Cyan'
}
$Magenta = @{
    Background = 'Black'
    Foreground = 'Magenta'
}
$Red = @{
    Background = 'Black'
    Foreground = 'Red'
}
$Yellow = @{
    Background = 'Black'
    Foreground = 'Yellow'
}



###FILE-END:Colors.ps1###

###FILE-START:Config.ps1###
#region read in or create an initial config file and variable
$ConfigFile = "Config.psd1"

if (Test-Path "$PSScriptRoot\$ConfigFile") {
    try {
	$Params     = @{
	    BaseDirectory = $PSScriptRoot
	    FileName      = $ConfigFile
	}
	$Config = Import-LocalizedData @Params
	foreach ($variable in $Config.keys) {
	    Write-Verbose "Setting $var variable."
	    New-Variable -Name "$variable" -Value $Config.$variable -Force
	    Export-ModuleMember -Variable $variable
	}
    } catch {
	Write-Warning "Invalid configuration data in $ConfigFile."
	Write-Warning "Please fill out or correct $PSScriptRoot\$ConfigFile."
	Write-Verbose $_.Exception.Message
	Write-Verbose $_.InvocationInfo.ScriptName
	Write-Verbose $_.InvocationInfo.PositionMessage
    }
} else {
    @"
@{
    Variable = ""
}
"@ | Out-File -Encoding UTF8 -FilePath "$PSScriptRoot\$ConfigFile"
    Write-Warning "Generated $PSScriptRoot\$ConfigFile."
    Write-Warning "Please edit $ConfigFile and re-import module."
}
#endregion



###FILE-END:Config.ps1###

###FILE-START:README.md###
# tcs.core Powershell Module

*Core Utility Functions for the suite of PowerShell modules*




###FILE-END:README.md###

###FILE-START:tcs.core.psd1###
@{
    ModuleVersion        = '0.1.7'
    GUID                 = 'a61ffd6a-dac4-4de4-a830-0e58a0535eaa'
    Author               = 'Nigel Tatschner'
    CompanyName          = 'Rothesay'
    Copyright            = '(c) 2024 Nigel Tatschner. All rights reserved.'
    Description          = 'Core functions required for the suite of modules.'
    CompatiblePSEditions = @('Desktop', 'Core')
    PowerShellVersion    = '5.1'
    NestedModules        = @('tcs.core.psm1')
    FunctionsToExport    = '*'
    CmdletsToExport      = '*'
    VariablesToExport    = '*'
    AliasesToExport      = '*'
    PrivateData          = @{
        PSData = @{
            Tags         = @( 'Core', 'Utility', 'Module', 'Telemetry' )
            ProjectUri   = ''
            ReleaseNotes = 'Adding new function ConvertTo-CamelCase'
        } 
    }
    HelpInfoURI          = 'https://PENDINGHOST/tcs.core/'
}


###FILE-END:tcs.core.psd1###

###FILE-START:tcs.core.psm1###
#region get public and private function definition files.
$Public  = @(
    Get-ChildItem -Path $PSScriptRoot\Public\*.ps1 -Exclude "*.Tests.ps1" -ErrorAction SilentlyContinue
)
$Private = @(
    Get-ChildItem -Path $PSScriptRoot\Private\*.ps1 -Exclude "*.Tests.ps1" -ErrorAction SilentlyContinue
)
#endregion

#region source the files
foreach ($Function in @($Public + $Private)) {
    $FunctionPath = $Function.fullname
    try {
	. $FunctionPath # dot source function
    } catch {
	Write-Error -Message "Failed to import function at $($FunctionPath): $_"
    }
}
#endregion
# Module Config setup and import
try {
    $CurrentConfig = Get-ModuleConfig -CommandPath $PSCommandPath -ErrorAction Stop
}
catch {
    Write-Error "Module Import error: `n $($_.Exception.Message)"
}

if ($CurrentConfig.UpdateWarning -eq 'True') {
    Get-ModuleStatus -ShowMessage -ModuleName $CurrentConfig.ModuleName -ModulePath $CurrentConfig.ModulePath
}
#endregion

#region export Public functions ($Public.BaseName) for WIP modules
Export-ModuleMember -Function $Public.Basename
Export-ModuleMember -Function Invoke-TelemetryCollection, Get-ModuleConfig, Get-ModuleStatus, Get-ParameterValues
#endregion


###FILE-END:tcs.core.psm1###

###FILE-START:Classes\README.md###
# tcs.core Classes



###FILE-END:Classes\README.md###

###FILE-START:Config\Module.Defaults.json###
{
    "UpdateWarning": "True"
}


###FILE-END:Config\Module.Defaults.json###

###FILE-START:Config\README.md###
# tcs.core Config



###FILE-END:Config\README.md###

###FILE-START:Private\Get-ModuleConfig.ps1###
function Get-ModuleConfig {
    [OutputType([hashtable])]

    param (
        [parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        $CommandPath
    )
    try {
        Write-Verbose "CommandPath: $CommandPath"
        $BaseCommandPath = Split-Path -Path $CommandPath -Parent
        Write-Verbose "Initial BaseCommandPath: $BaseCommandPath"
        # Recursively step back through the CommandPath to find the module path that contains the module manifest file and get the module base path and module name
        while (-not (Get-ChildItem -Path $BaseCommandPath -Filter *.psd1)) {
            $ParentPath = Split-Path -Path $BaseCommandPath -Parent
            Write-Verbose "ParentPath: $ParentPath"
            if ($ParentPath -eq $BaseCommandPath) {
                Write-Verbose "ParentPath: $ParentPath is the same as BaseCommandPath: $BaseCommandPath"
                # Break the loop if the parent path is the same as the current path,
                # indicating that we've reached the root directory
                break
            }
            $BaseCommandPath = $ParentPath
            Write-Verbose "Recursive BaseCommandPath: $BaseCommandPath"
        }
        $ModuleFilePath = Join-Path -Path $BaseCommandPath -ChildPath $(Split-Path -Path $(Get-ChildItem -Path $BaseCommandPath -Filter *.psd1 | Select-Object -First 1) -Leaf)
        Write-Verbose "ModuleFilePath: $ModuleFilePath"
        $ModuleVersion = (Import-PowerShellDataFile -Path $($ModuleFilePath.Replace('.psm1','.psd1'))).ModuleVersion
        $ModulePath = Split-Path -Path $ModuleFilePath -Parent
        if ([string]::IsNullOrEmpty($ModulePath)) {
            Write-Error "ModulePath is empty or null."
            throw
        }
        Write-Verbose "ModulePath: $ModulePath"
        $ModuleName = Get-ChildItem -Path $ModuleFilePath -Filter "*.psd1" -File | Select-Object -First 1 | Select-Object -ExpandProperty BaseName
        Write-Verbose "ModuleName: $ModuleName"
        $UserPowerShellModuleConfigPath = Join-Path -Path $(Split-Path -Path $($env:PSModulePath -split ';' | ForEach-Object { if (($_ -match $([regex]::Escape($env:USERNAME))) -and ($_ -notmatch '\.')) { $_ } }) -Parent) -ChildPath 'Config'
        Write-Verbose "UserPowerShellModuleConfigPath: $UserPowerShellModuleConfigPath"
        $ModuleConfigPath = Join-Path -Path $UserPowerShellModuleConfigPath -ChildPath $ModuleName
        Write-Verbose "ModuleConfigPath: $ModuleConfigPath"
        $ModuleConfigFilePath = Join-Path -Path $ModuleConfigPath -ChildPath 'Module.Config.json'
        Write-Verbose "ModuleConfigFilePath: $ModuleConfigFilePath"
        $ConfigDefaultsPath = Join-Path -Path $(Split-Path -Path $PSScriptRoot -Parent) -ChildPath "\Config\Module.Defaults.json"
        Write-Verbose "ConfigDefaultsPath: $ConfigDefaultsPath"
        $DefaultConfig = Get-Content -Path $ConfigDefaultsPath | ConvertFrom-Json
        Write-Verbose "DefaultConfig: $DefaultConfig"
    }
    catch {
        Write-Error "CommandPath: $($CommandPath)`nError: `n$($_)`n Invocation $($_.InvocationInfo.ScriptLineNumber) $($_.InvocationInfo.ScriptName)"
        return
    }
    # Test to see if module config JSON exists and create it if it doesn't
    if (-not (Test-Path -Path $ModuleConfigFilePath)) {
        $HashTable = @{}
        $DefaultConfig.PSObject.Properties | ForEach-Object { $HashTable[$_.Name] = $_.Value }
        $HashTable.Add('ModuleName', $ModuleName)
        $HashTable.Add('ModulePath', $ModulePath)
        $HashTable.Add('ModuleVersion', $ModuleVersion)
        $HashTable.Add('ModuleConfigPath', $ModuleConfigPath)
        $HashTable.Add('ModuleConfigFilePath', $ModuleConfigFilePath)
        New-Item -Path $ModuleConfigFilePath -ItemType File -Value $($HashTable | ConvertTo-Json) -Force -Confirm:$false
    }
    else {
        $Config = Get-Content -Path $ModuleConfigFilePath | ConvertFrom-Json
        $DefaultConfig.PSObject.Properties | ForEach-Object {
            if ($Config.PSObject.Properties.Name -notcontains $_.Name) {
                $Config | Add-Member -MemberType NoteProperty -Name $_.Name -Value $_.Value
            }
        }
        # Update Module Path if it has changed
        $CurrentlyLoadedModuleVersion = (Import-PowerShellDataFile -Path $($ModuleFilePath.Replace('.psm1','.psd1'))).ModuleVersion
        if ($Config.ModuleVersion -ne $CurrentlyLoadedModuleVersion) {
            $Config.ModuleVersion = $CurrentlyLoadedModuleVersion
            $Config | ConvertTo-Json | Set-Content -Path $ModuleConfigFilePath -Force -Confirm:$false
            $Config = Get-Content -Path $ModuleConfigFilePath | ConvertFrom-Json
        }
        if ($Config.ModulePath -ne $ModulePath) {
            $Config.ModulePath = $ModulePath
            $Config | ConvertTo-Json | Set-Content -Path $ModuleConfigFilePath -Force -Confirm:$false
            $Config = Get-Content -Path $ModuleConfigFilePath | ConvertFrom-Json
        }
        $HashTable = @{}
        $Config.PSObject.Properties | ForEach-Object { $HashTable[$_.Name] = $_.Value }
        $HashTable
    }
}


###FILE-END:Private\Get-ModuleConfig.ps1###

###FILE-START:Private\Get-ModuleStatus.ps1###
function Get-ModuleStatus {
    param (
        [switch]$ShowMessage,

        [ValidateNotNullOrEmpty()]
        [Parameter(Mandatory)]
        [string]$ModuleName,

        [ValidateNotNullOrEmpty()]
        [Parameter(Mandatory)]
        [string]$ModulePath
    )
    try {
        # Get the current version of the installed module and check against the latest version in PSGallery, then notify the user as a warning message that an update is availible.
        $PSD1File = Join-Path -Path $ModulePath -ChildPath "$ModuleName.psd1"
        if ($ShowMessage) {
            $CurrentlyLoadedModuleVersion = (Import-PowerShellDataFile -Path $PSD1File).ModuleVersion
            $LatestModuleVersion = (Find-PSResource -Name $ModuleName).Version
            if ($CurrentlyLoadedModuleVersion -lt $LatestModuleVersion) {
                Write-Host -ForegroundColor Yellow "An update is available for the module '$ModuleName'. Installed version: $CurrentlyLoadedModuleVersion, Latest version: $LatestModuleVersion.`nPlease run 'Update-Module $ModuleName' to update the module."
            }
            return
        }
        else {
            return
        }
    }
    catch {
        return
    }
}


###FILE-END:Private\Get-ModuleStatus.ps1###

###FILE-START:Private\Get-ParameterValues.ps1###
function Get-ParameterValues {
    [OutputType([hashtable])]
    param(
        [Parameter(Mandatory)]
        [hashtable]$PSBoundParametersHash,
        [string[]]$Exclude
    )
    # Get all the PSBoundParameters and set the values as a hashtable
    $DefaultExclude = @('Verbose', 'Debug', 'ErrorAction', 'WarningAction', 'InformationAction', 'ErrorVariable', 'WarningVariable', 'InformationVariable', 'OutVariable', 'OutBuffer', 'PipelineVariable')
    if ($null -eq $Exclude) {
        $Exclude = $DefaultExclude
    } else {
        $Exclude += $DefaultExclude
    }
    $Parameters = New-Object System.Collections.Hashtable
    $PSBoundParametersHash.GetEnumerator() | ForEach-Object {
        # Only add the key and value to the hashtable if the value is not null and not the default parameters
        if ($null -ne $_.Value -and $Exclude -notcontains $_.Key) {
            $Key = $_.Key
            $Value = $_.Value
            $Parameters.Add($Key, $Value)
        }
    }
    $Parameters
}


###FILE-END:Private\Get-ParameterValues.ps1###

###FILE-START:Private\Invoke-TelemetryCollection.ps1###
function Invoke-TelemetryCollection {
    param (
        [CmdletBinding(HelpUri = 'https://PENDINGHOST/tcs.core/docs/Invoke-TelemetryCollection.html')]

        [string]$ModuleName = 'UnknownModule',

        [string]$ModuleVersion = 'UnknownModuleVersion',

        [string]$ModulePath = 'UnknownModulePath',

        [string]$CommandName = 'UnknownCommand',
        
        [Parameter(Mandatory = $true)]
        [string]$ExecutionID = 'UnknownExecutionID',

        [Parameter(Mandatory = $true)]
        [ValidateSet('Start', 'In-Progress', 'End', 'Module-Load')]
        [string]$Stage,

        [bool]$Failed = $false,

        [string]$Exception,

        [switch]$Minimal,

        [switch]$ClearTimer,

        [Parameter(Mandatory = $true)]
        [string]$URI
    )

    $CurrentTime = (Get-Date).ToString("yyyy-MM-ddTHH:mm:sszzz")

    switch -Regex ($Stage) {
        'Module-Load' {
            if ((Get-Variable -Name "GlobalExecutionDuration_$ExecutionID" -Scope script -ErrorAction SilentlyContinue) -and (-Not $ClearTimer)) {
                Set-Variable -Name "GlobalExecutionDuration_$ExecutionID" -Value (Get-Variable -Name "GlobalExecutionDuration_$ExecutionID" -Scope script -ErrorAction SilentlyContinue) -Scope script -Force | Out-Null
            }
            else {
                New-Variable -Name "GlobalExecutionDuration_$ExecutionID" -Value $(Get-Date) -Scope script -Force | Out-Null
            }
        }
        'Start' {
            if ((Get-Variable -Name "GlobalExecutionDuration_$ExecutionID" -Scope script -ErrorAction SilentlyContinue) -and (-Not $ClearTimer)) {
                Set-Variable -Name "GlobalExecutionDuration_$ExecutionID" -Value (Get-Variable -Name "GlobalExecutionDuration_$ExecutionID" -Scope script -ErrorAction SilentlyContinue) -Scope script -Force | Out-Null
            }
            else {
                New-Variable -Name "GlobalExecutionDuration_$ExecutionID" -Value $(Get-Date) -Scope script -Force | Out-Null
            }
        }
        "End|Module-Load" {
            Start-Job -Name "TC_Job_Trying_To_Be_Unique_9000" -ArgumentList $(Get-Variable -Name "GlobalExecutionDuration_$ExecutionID" -ErrorAction SilentlyContinue).Value -ScriptBlock {
                param ($GlobalExecutionDuration)
                $ExecutionDuration = [Int64]$($(New-TimeSpan -Start $GlobalExecutionDuration -End $(Get-Date)).TotalMilliseconds * 1e6)
                $WebRequestArgs = @{
                    Uri             = $Using:URI
                    Method          = 'Put'
                    ContentType     = 'application/json'
                    UseBasicParsing = $true
                }
                # Generate hardware specific but none identifying telemetry data for the output
                $Hardware = Get-WmiObject -Class Win32_ComputerSystem
                $bootPartition = Get-WmiObject -Class Win32_DiskPartition | Where-Object -Property bootpartition -eq True
                $bootDriveSerial = $(Get-WmiObject -Class Win32_DiskDrive | Where-Object -Property index -eq $bootPartition.diskIndex)
                if ([string]::IsNullOrEmpty($bootDriveSerial.SerialNumber) -and ($bootDriveSerial.Model -like '*Virtual*')) {
                    $bootDriveSerial = "VirtualDrive-$($bootDriveSerial.size)"
                }
                else {
                    $bootDriveSerial = $bootDriveSerial.SerialNumber.Trim()
                }

                $HardwareData = @{
                    Manufacturer              = $Hardware.Manufacturer
                    Model                     = $Hardware.Model
                    TotalPhysicalMemory       = $Hardware.TotalPhysicalMemory
                    NumberOfProcessors        = $Hardware.NumberOfProcessors
                    NumberOfLogicalProcessors = $Hardware.NumberOfLogicalProcessors
                    PartOfDomain              = $Hardware.PartOfDomain
                    HardwareSerialNumber      = $((Get-WmiObject -Class Win32_BIOS).SerialNumber)
                    BootDriveSerial           = $bootDriveSerial
                }

                # Generate OS specific but none identifying telemetry data for the output
                $OS = Get-WmiObject -Class Win32_OperatingSystem

                $OSData = @{
                    OSType         = $OS.Caption
                    OSArchitecture = $OS.OSArchitecture
                    OSVersion      = $OS.Version
                    OSBuildNumber  = $OS.BuildNumber
                    SerialNumber   = $OS.SerialNumber
                }

                # Generate PowerShell specific but none identifying telemetry data for the output

                $PSData = @{
                    PowerShellVersion = $PSVersionTable.PSVersion.ToString()
                    HostVersion       = $Host.Version.ToString()
                    HostName          = $Host.Name.ToString()
                    HostUI            = $Host.UI.ToString()
                    HostCulture       = $Host.CurrentCulture.ToString()
                    HostUICulture     = $Host.CurrentUICulture.ToString()
                }

                # Generate module specific but none identifying telemetry data for the output

                $ModuleData = @{
                    ModuleName    = if ([string]::IsNullOrEmpty($Using:ModuleName)) { 'UnknownModule' } else { $Using:ModuleName }
                    ModuleVersion = if ([string]::IsNullOrEmpty($Using:ModuleVersion)) { 'UnknownModuleVersion' } else { $Using:ModuleVersion }
                    ModulePath    = if ([string]::IsNullOrEmpty($Using:ModulePath)) { 'UnknownModulePath' } else { $Using:ModulePath }
                    CommandName   = if ([string]::IsNullOrEmpty($Using:CommandName)) { 'UnknownCommand' } else { $Using:CommandName }
                }
                # Create a new hashtable
                $AllData = @{}

                # Add each hashtable to the new hashtable
                $AllData += $HardwareData
                $AllData += $OSData
                $AllData += $PSData
                $AllData += $ModuleData
                $AllData += @{ID = $AllData.BootDriveSerial + "_" + $AllData.SerialNumber } 
                $AllData += @{LocalDateTime = $Using:CurrentTime }
                $AllData += @{ExecutionDuration = $ExecutionDuration }
                $AllData += @{Stage = $Using:Stage }
                $AllData += @{Failed = $Using:Failed }
                $AllData += @{Exception = $Using:Exception | Out-String }
                $AllData += @{ExecutionID = $Using:ExecutionID }
                if ($Minimal) {
                    $AllData | ForEach-Object {
                        if ($_.Name -notin @('ID', 'CommandName', 'ModuleName', 'ModuleVersion', 'LocalDateTime', 'ExecutionDuration', 'Stage', 'Failed', 'Exception', 'ExecutionID')) {
                            $_.Value = 'Minimal'
                        }
                        $body = $AllData | ConvertTo-Json
                        Invoke-WebRequest @WebRequestArgs -Body $body | Out-Null
                    }
                }
                else {
                    $body = $AllData | ConvertTo-Json
                    Invoke-WebRequest @WebRequestArgs -Body $body | Out-Null
                }
            } | Out-Null
            # Clear Old Jobs
            Get-Job -Name "TC_Job_Trying_To_Be_Unique_9000" -ErrorAction SilentlyContinue | Where-Object State -in Completed, Failed | Remove-Job -Force -ErrorAction SilentlyContinue | Out-Null
        }
    }
}


###FILE-END:Private\Invoke-TelemetryCollection.ps1###

###FILE-START:Private\README.md###
# tcs.core Private



###FILE-END:Private\README.md###

###FILE-START:Private\Tests\Get-ModuleConfig.Tests.ps1###
BeforeAll {
	$TestPath = Split-Path -Parent -Path $PSScriptRoot

	$FunctionFileName = (Split-Path -Leaf $PSCommandPath ) -replace '\.Tests\.', '.'

	# You can use this Variable to call your function via it's name or ignore/remove as required
	$FunctionName = $FunctionFileName.Replace('.ps1', '')
	
	. $(Join-Path -Path $TestPath -ChildPath $FunctionFileName)
}
Describe -Name "Performing basic validation test on function $FunctionFileName" {
	It "Function $FunctionFileName - Testing Command Output Object" {
		# This is a template for the Pester Test, add any tests you want here
	}
}

Describe -Tags 'PSSA' -Name 'Testing against PSScriptAnalyzer rules' {
	BeforeAll {
		$ScriptAnalyzerSettings = Get-Content -Path (Join-Path -Path (Get-Location) -ChildPath 'PSScriptAnalyzerSettings.psd1') | Out-String | Invoke-Expression
		$AnalyzerIssues = Invoke-ScriptAnalyzer -Path "$TestPath\$FunctionFileName" -Settings $ScriptAnalyzerSettings
		$ScriptAnalyzerRuleNames = Get-ScriptAnalyzerRule | Select-Object -ExpandProperty RuleName
	}

	foreach ($Rule in $ScriptAnalyzerRuleNames) {
		if ($ScriptAnalyzerSettings.excluderules -notcontains $Rule) {
			It "Function $FunctionFileName should pass $Rule" {
				$Failures = $AnalyzerIssues | Where-Object -Property RuleName -EQ -Value $rule
				($Failures | Measure-Object).Count | Should -Be 0
			}
		}
		else {
			# We still want it in the tests, but since it doesn't actually get tested we will skip
			It "Function $FunctionFileName should pass $Rule" -Skip {
				$Failures = $AnalyzerIssues | Where-Object -Property RuleName -EQ -Value $rule
				($Failures | Measure-Object).Count | Should -Be 0
			}
		}
	}
}


###FILE-END:Private\Tests\Get-ModuleConfig.Tests.ps1###

###FILE-START:Private\Tests\Get-ModuleStatus.Tests.ps1###
BeforeAll {
	$TestPath = Split-Path -Parent -Path $PSScriptRoot

	$FunctionFileName = (Split-Path -Leaf $PSCommandPath ) -replace '\.Tests\.', '.'

	# You can use this Variable to call your function via it's name or ignore/remove as required
	$FunctionName = $FunctionFileName.Replace('.ps1', '')
	
	. $(Join-Path -Path $TestPath -ChildPath $FunctionFileName)
}
Describe -Name "Performing basic validation test on function $FunctionFileName" {
	It "Function $FunctionFileName - Testing Command Output Object" {
		# This is a template for the Pester Test, add any tests you want here
	}
}

Describe -Tags 'PSSA' -Name 'Testing against PSScriptAnalyzer rules' {
	BeforeAll {
		$ScriptAnalyzerSettings = Get-Content -Path (Join-Path -Path (Get-Location) -ChildPath 'PSScriptAnalyzerSettings.psd1') | Out-String | Invoke-Expression
		$AnalyzerIssues = Invoke-ScriptAnalyzer -Path "$TestPath\$FunctionFileName" -Settings $ScriptAnalyzerSettings
		$ScriptAnalyzerRuleNames = Get-ScriptAnalyzerRule | Select-Object -ExpandProperty RuleName
	}

	foreach ($Rule in $ScriptAnalyzerRuleNames) {
		if ($ScriptAnalyzerSettings.excluderules -notcontains $Rule) {
			It "Function $FunctionFileName should pass $Rule" {
				$Failures = $AnalyzerIssues | Where-Object -Property RuleName -EQ -Value $rule
				($Failures | Measure-Object).Count | Should -Be 0
			}
		}
		else {
			# We still want it in the tests, but since it doesn't actually get tested we will skip
			It "Function $FunctionFileName should pass $Rule" -Skip {
				$Failures = $AnalyzerIssues | Where-Object -Property RuleName -EQ -Value $rule
				($Failures | Measure-Object).Count | Should -Be 0
			}
		}
	}
}


###FILE-END:Private\Tests\Get-ModuleStatus.Tests.ps1###

###FILE-START:Private\Tests\Get-ParameterValues.Tests.ps1###
BeforeAll {
	$TestPath = Split-Path -Parent -Path $PSScriptRoot

	$FunctionFileName = (Split-Path -Leaf $PSCommandPath ) -replace '\.Tests\.', '.'

	# You can use this Variable to call your function via it's name or ignore/remove as required
	$FunctionName = $FunctionFileName.Replace('.ps1', '')
	
	. $(Join-Path -Path $TestPath -ChildPath $FunctionFileName)
}
Describe -Name "Performing basic validation test on function $FunctionFileName" {
	It "Function $FunctionFileName - Testing Command Output Object" {
		# This is a template for the Pester Test, add any tests you want here
	}
}

Describe -Tags 'PSSA' -Name 'Testing against PSScriptAnalyzer rules' {
	BeforeAll {
		$ScriptAnalyzerSettings = Get-Content -Path (Join-Path -Path (Get-Location) -ChildPath 'PSScriptAnalyzerSettings.psd1') | Out-String | Invoke-Expression
		$AnalyzerIssues = Invoke-ScriptAnalyzer -Path "$TestPath\$FunctionFileName" -Settings $ScriptAnalyzerSettings
		$ScriptAnalyzerRuleNames = Get-ScriptAnalyzerRule | Select-Object -ExpandProperty RuleName
	}

	foreach ($Rule in $ScriptAnalyzerRuleNames) {
		if ($ScriptAnalyzerSettings.excluderules -notcontains $Rule) {
			It "Function $FunctionFileName should pass $Rule" {
				$Failures = $AnalyzerIssues | Where-Object -Property RuleName -EQ -Value $rule
				($Failures | Measure-Object).Count | Should -Be 0
			}
		}
		else {
			# We still want it in the tests, but since it doesn't actually get tested we will skip
			It "Function $FunctionFileName should pass $Rule" -Skip {
				$Failures = $AnalyzerIssues | Where-Object -Property RuleName -EQ -Value $rule
				($Failures | Measure-Object).Count | Should -Be 0
			}
		}
	}
}


###FILE-END:Private\Tests\Get-ParameterValues.Tests.ps1###

###FILE-START:Private\Tests\Invoke-TelemetryCollection.Tests.ps1###
BeforeAll {
	$TestPath = Split-Path -Parent -Path $PSScriptRoot

	$FunctionFileName = (Split-Path -Leaf $PSCommandPath ) -replace '\.Tests\.', '.'

	# You can use this Variable to call your function via it's name or ignore/remove as required
	$FunctionName = $FunctionFileName.Replace('.ps1', '')
	
	. $(Join-Path -Path $TestPath -ChildPath $FunctionFileName)
}
Describe -Name "Performing basic validation test on function $FunctionFileName" {
	It "Function $FunctionFileName - Testing Command Output Object" {
		# This is a template for the Pester Test, add any tests you want here
	}
}

Describe -Tags 'PSSA' -Name 'Testing against PSScriptAnalyzer rules' {
	BeforeAll {
		$ScriptAnalyzerSettings = Get-Content -Path (Join-Path -Path (Get-Location) -ChildPath 'PSScriptAnalyzerSettings.psd1') | Out-String | Invoke-Expression
		$AnalyzerIssues = Invoke-ScriptAnalyzer -Path "$TestPath\$FunctionFileName" -Settings $ScriptAnalyzerSettings
		$ScriptAnalyzerRuleNames = Get-ScriptAnalyzerRule | Select-Object -ExpandProperty RuleName
	}

	foreach ($Rule in $ScriptAnalyzerRuleNames) {
		if ($ScriptAnalyzerSettings.excluderules -notcontains $Rule) {
			It "Function $FunctionFileName should pass $Rule" {
				$Failures = $AnalyzerIssues | Where-Object -Property RuleName -EQ -Value $rule
				($Failures | Measure-Object).Count | Should -Be 0
			}
		}
		else {
			# We still want it in the tests, but since it doesn't actually get tested we will skip
			It "Function $FunctionFileName should pass $Rule" -Skip {
				$Failures = $AnalyzerIssues | Where-Object -Property RuleName -EQ -Value $rule
				($Failures | Measure-Object).Count | Should -Be 0
			}
		}
	}
}


###FILE-END:Private\Tests\Invoke-TelemetryCollection.Tests.ps1###

###FILE-START:Private\Tests\PSScriptAnalyzerSettings.psd1###
@{
# Limit tests to Warning or Error
Severity=@('Error','Warning')
# Exclude the following rule(s) ( Separated by a comma)
ExcludeRules=@('PSAvoidUsingInvokeExpression')
}


###FILE-END:Private\Tests\PSScriptAnalyzerSettings.psd1###

###FILE-START:Private\Tests\README.md###
# tcs.core Private\Tests



###FILE-END:Private\Tests\README.md###

###FILE-START:Public\ConvertTo-CamelCase.ps1###
function ConvertTo-CamelCase {
    param([string]$value)
    if ([string]::IsNullOrEmpty($value)) { return $value }
    $value.Substring(0,1).ToLower() + $value.Substring(1)
}


###FILE-END:Public\ConvertTo-CamelCase.ps1###

###FILE-START:Public\New-DynamicParameter.ps1###
<#
.DESCRIPTION
    Sometimes different parameters are only relevant in certain circumatances. We use dynamicparam to add those mandatory parameters on the fly
    This helper reduces the amount of boilerplate required to build a dynamic param
.PARAMETER Name
    The name of the dynamic parameter to add
.PARAMETER Type
    The type of the dynamic parameter
.PARAMETER ParameterSetName 
    The parameter set name
    Defaults to: '__AllParameterSets' (aka no parameter set)
.PARAMETER Mandatory
    Set to make the parameter mandatory
.PARAMETER Position
    The position of the parameter
.PARAMETER ValueFromPipelineByPropertyName
    Set to make the parameter have the ValueFromPipelineByPropertyName property
.PARAMETER HelpMessage
    The help message for the parameter
.PARAMETER ValidateSet
    The validate set to apply to the parameter
.PARAMETER IgnoreCase 
    If set the validate set on the parameter being created does not check case
    Defaults to: $true
.PARAMETER ValidateScript
    The validate script to apply to the parameter
.PARAMETER DefaultValue
    The default value of the parameter
#>
function New-DynamicParameter {
    [CmdletBinding(DefaultParameterSetName = 'Core')]    
    param (
        [Parameter(Mandatory, ValueFromPipeline)]
        [string]
        $Name,
        
        [Parameter(Mandatory)]
        [System.Type]
        $ParameterType,

        [string]
        $ParameterSetName = '__AllParameterSets',
        
        [switch]
        $Mandatory,

        [int]
        $Position,

        [switch]
        $ValueFromPipelineByPropertyName,

        [string]
        $HelpMessage,

        [Parameter(Mandatory, ParameterSetName = 'ValidateSet')]
        [string[]]
        $ValidateSet,

        [Parameter(ParameterSetName = 'ValidateSet')]
        [bool]
        $IgnoreCase = $true,

        [Parameter(Mandatory, ParameterSetName = 'ValidateScript')]
        [scriptblock]
        $ValidateScript
    )

    process {
        $parameterAttribute = New-Object System.Management.Automation.ParameterAttribute
        $attributeCollection = New-Object Collections.ObjectModel.Collection[System.Attribute]
        if ([string]::IsNullOrEmpty($ParameterSetName) -eq $false) {
            $parameterAttribute.ParameterSetName = $ParameterSetName
        }
        if ([string]::IsNullOrEmpty($Mandatory) -eq $false) {
            $parameterAttribute.Mandatory = $Mandatory
        }
        if ([string]::IsNullOrEmpty($Position) -eq $false) {
            $parameterAttribute.Position = $Position
        }
        if ([string]::IsNullOrEmpty($ValueFromPipelineByPropertyName) -eq $false) {
            $parameterAttribute.ValueFromPipelineByPropertyName = $ValueFromPipelineByPropertyName
        }
        if (-not [String]::IsNullOrEmpty($HelpMessage)) {
            $parameterAttribute.HelpMessage = $HelpMessage
        }
        if (-not [String]::IsNullOrEmpty($ValidateSet)) {
            if ($PSCmdlet.ParameterSetName -eq 'ValidateSet') {
                $parameterValidateSet = New-Object System.Management.Automation.ValidateSetAttribute -ArgumentList $ValidateSet
                $parameterValidateSet.IgnoreCase = $IgnoreCase
            }
            $attributeCollection.Add($parameterValidateSet)
        }
        if (-not [String]::IsNullOrEmpty($ValidateScript)) {
            if ($PSCmdlet.ParameterSetName -eq 'ValidateScript') {
                $parameterValidateScript = New-Object System.Management.Automation.ValidateScriptAttribute -ArgumentList $ValidateScript
            }
            $attributeCollection.Add($parameterValidateScript)
        }

        $attributeCollection.Add($parameterAttribute)

        $parameter = New-Object System.Management.Automation.RuntimeDefinedParameter -ArgumentList @($Name, $ParameterType, $attributeCollection)

        [pscustomobject]@{
            Name      = $Name
            Parameter = $parameter
        }
    }
}


###FILE-END:Public\New-DynamicParameter.ps1###

###FILE-START:Public\README.md###
# tcs.core Public



###FILE-END:Public\README.md###

###FILE-START:Public\Set-ModuleConfig.ps1###
function Set-ModuleConfig {
    [CmdletBinding(HelpUri = 'https://PENDINGHOST/tcs.core/docs/Set-ModuleConfig.html')]
    param(
        [Parameter(HelpMessage = "Determines if the update message is displayed when the module is loaded.")]
        [ValidateSet('True', 'False')]
        [string]$UpdateWarning,
    
        [Parameter(HelpMessage = "Name of the module the configurationis being set for.")]
        [string]$ModuleName,

        [Parameter(HelpMessage = "Path of the module config.")]
        [string]$ModuleConfigFilePath,

        [Parameter(HelpMessage = "Path of the module.")]
        [string]$ModuleConfigPath,

        [Parameter(HelpMessage = "Path of the module.")]
        [string]$ModulePath,

        [switch]$BasicTelemetry
    )

    # Test to see if module config JSON exists and create it if it doesn't
    if (-not (Test-Path -Path $ModuleConfigFilePath)) {
        New-Item -Path $ModuleConfigFilePath -ItemType File -Force -Confirm:$false | Out-Null
        $NewConfig = Get-ParameterValues -PSBoundParametersHash $PSBoundParameters
        $NewConfig | ConvertTo-Json | Set-Content -Path $ModuleConfigFilePath -Force -Confirm:$false
    }
    else {
        # Read the module config JSON
        $Config = (Get-Content -Path $ModuleConfigFilePath | ConvertFrom-Json)
        $ConfigHashTable = @{}
        $Config.PSObject.Properties | ForEach-Object { $ConfigHashTable[$_.Name] = $_.Value }
        # Update or add new values to the module config JSON
        $NewConfig = Get-ParameterValues -PSBoundParametersHash $PSBoundParameters
        Write-Verbose "Updating module config with the following values: $NewConfig"
        $NewConfig.GetEnumerator() | ForEach-Object {
            $Key = $_.Key
            $Value = $_.Value
            if ($ConfigHashTable.ContainsKey($Key)) {
                $ConfigHashTable[$Key] = $Value
            }
            else {
                $ConfigHashTable.Add($Key, $Value)
            }
        }
        $ConfigHashTable | ConvertTo-Json | Set-Content -Path $ModuleConfigFilePath -Force -Confirm:$false
    }
}


###FILE-END:Public\Set-ModuleConfig.ps1###

###FILE-START:Public\Tests\PSScriptAnalyzerSettings.psd1###
@{
# Limit tests to Warning or Error
Severity=@('Error','Warning')
# Exclude the following rule(s) ( Separated by a comma)
ExcludeRules=@('PSAvoidUsingInvokeExpression')
}


###FILE-END:Public\Tests\PSScriptAnalyzerSettings.psd1###

###FILE-START:Public\Tests\README.md###
# tcs.core Public\Tests



###FILE-END:Public\Tests\README.md###

###FILE-START:Public\Tests\Set-ModuleConfig.Tests.ps1###
BeforeAll {
	$TestPath = Split-Path -Parent -Path $PSScriptRoot

	$FunctionFileName = (Split-Path -Leaf $PSCommandPath ) -replace '\.Tests\.', '.'

	# You can use this Variable to call your function via it's name or ignore/remove as required
	$FunctionName = $FunctionFileName.Replace('.ps1', '')
	
	. $(Join-Path -Path $TestPath -ChildPath $FunctionFileName)
}
Describe -Name "Performing basic validation test on function $FunctionFileName" {
	It "Function $FunctionFileName - Testing Command Output Object" {
		# This is a template for the Pester Test, add any tests you want here
	}
}

Describe -Tags 'PSSA' -Name 'Testing against PSScriptAnalyzer rules' {
	BeforeAll {
		$ScriptAnalyzerSettings = Get-Content -Path (Join-Path -Path (Get-Location) -ChildPath 'PSScriptAnalyzerSettings.psd1') | Out-String | Invoke-Expression
		$AnalyzerIssues = Invoke-ScriptAnalyzer -Path "$TestPath\$FunctionFileName" -Settings $ScriptAnalyzerSettings
		$ScriptAnalyzerRuleNames = Get-ScriptAnalyzerRule | Select-Object -ExpandProperty RuleName
	}

	foreach ($Rule in $ScriptAnalyzerRuleNames) {
		if ($ScriptAnalyzerSettings.excluderules -notcontains $Rule) {
			It "Function $FunctionFileName should pass $Rule" {
				$Failures = $AnalyzerIssues | Where-Object -Property RuleName -EQ -Value $rule
				($Failures | Measure-Object).Count | Should -Be 0
			}
		}
		else {
			# We still want it in the tests, but since it doesn't actually get tested we will skip
			It "Function $FunctionFileName should pass $Rule" -Skip {
				$Failures = $AnalyzerIssues | Where-Object -Property RuleName -EQ -Value $rule
				($Failures | Measure-Object).Count | Should -Be 0
			}
		}
	}
}


###FILE-END:Public\Tests\Set-ModuleConfig.Tests.ps1###

